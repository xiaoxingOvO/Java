<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    /*原型是指当我们想要创建xiaoming这个具体的学生时，我们并没有一个Student类型可用。那怎么办？恰好有这么一个现成的对象*/
    var Student = {
        name: 'Robot',
        height: 1.2,
        run: function () {
            console.log(this.name + ' is running...');
        }
    };
    //我们看这个robot对象有名字，有身高，还会跑，有点像小明，干脆就根据它来“创建”小明得了！
    //于是我们把它改名为Student，然后创建出xiaoming：
    var xiaoming = {
        name: '小明'
    };
    //这一行代码把xiaoming的原型指向了对象Student，看上去xiaoming仿佛是从Student继承下来的：
    xiaoming.__proto__ = Student;

    //输出
    console.log(xiaoming.name);// '小明'
    xiaoming.run(); // 小明 is running...
</script>

<!--创建对象-->
<script>
    <!--创建一个arr对象-->
    var arr = [1, 2, 3];

    /*构造函数的方法来创建对象。*/
    function Student(name) {
        this.name = name;
        this.hello = function () {
            alert('Hello, ' + this.name + '!');
        }
    }
    var xiaoming = new Student('小明');

</script>

<!--class继承-->
<script>
    <!--函数实现Student的方法-->
    // function Student(name) {
    //     this.name = name;
    // }
    //
    // Student.prototype.hello = function () {
    //     alert('Hello, ' + this.name + '!');
    // }

    /*class关键字来编写Student，可以这样写：
    * class的定义包含了构造函数constructor和定义在原型对象上的函数hello()（注意没有function关键字）
    */
    class Student {
        constructor(name) {
            this.name = name;
        }

        hello() {
            alert('Hello, ' + this.name + '!');
        }
    }
    // 创建一个Student对象
    var xiaoming = new Student('小明');
    xiaoming.hello();


    //用`class`定义对象的另一个巨大的好处是继承更方便了,直接通过`extends`来实现：
    class PrimaryStudent extends Student {
        constructor(name, grade) {
            super(name); // 记得用super调用父类的构造方法!
            this.grade = grade;
        }

        myGrade() {
            alert('I am at grade ' + this.grade);
        }
    }

</script>

</body>
</html>